# -*- coding: utf-8 -*-
"""gaussian_output_plotter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wzuYlIAi16Qct2jKSbUSxNbmG_Co1Kne
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from scipy.interpolate import griddata
from scipy.optimize import curve_fit

def outfiles_to_df(directory: str):

    mol = directory.split('/')[-1].replace('outfiles', '')

    if (mol+'.csv') in os.listdir(directory):
        df = pd.read_csv(directory+'/'+mol+'.csv', index_col=0)
        return df

    else:
        rs = []
        thetas = []
        Es = []
        n_files = 0

        for filename in os.listdir(directory):
            f = open(directory+'/'+filename, 'r')
            filename_without_ext = os.path.splitext(filename)[0]
            data = filename_without_ext.split('r')[1].split('theta')
            r = data[0]
            theta = data[1]
            i = 0
            for line in f:
                if 'SCF Done:' in line:
                    line_E = line.split()
                    E = line_E[4]
                    break
                i += 1
            print(n_files, r, theta, E)
            rs.append(r)
            thetas.append(theta)
            Es.append(E)
            f.close()
            n_files += 1

        print(rs, thetas, Es)
        d = {'r': rs, 'theta': thetas, 'Energy': Es}
        df = pd.DataFrame(d)
        df.to_csv('/content/drive/My Drive/Part II Programming Practicals/Exercise 2/'+mol+'.csv')
        return df

def plot_energy_surface(df: pd.DataFrame):
    r, t = np.meshgrid(np.linspace(min(df['r']), max(df['r'])), np.linspace(min(df['theta']), max(df['theta'])))
    e = griddata((df['r'],df['theta']), df['Energy'], (r, t), method = 'linear')
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.set_xlabel('r/Angstroms')
    ax.set_ylabel('theta/degrees')
    ax.set_zlabel('Energy/Hartrees')
    #ax.set_zlim(min(df['Energy']), (max(df['Energy'])-2))
    surf = ax.plot_surface(r, t, e, rstride=1, cstride=1, cmap=cm.coolwarm)
    fig.colorbar(surf, shrink=0.5, aspect=5)
    plot = plt.show()
    return plot

def find_min(df: pd.DataFrame):
    idx_min = int(df.idxmin(axis=0)[2])
    min_row = df.loc[idx_min, :]
    r_min, theta_min, E_min = min_row[0], min_row[1], min_row[2]
    return r_min, theta_min, E_min

def fit_curve(df: pd.DataFrame):
    r_min, theta_min, E_min = find_min(df)
    r_range_min, r_range_max = r_min - 0.2, r_min + 0.2
    theta_range_min, theta_range_max = theta_min - 30, theta_min + 30
    fit_df = df.query('r >= @r_range_min & r <= @r_range_max & theta >= @theta_range_min & theta <= @theta_range_max')
    def vibrational_model(X, k_r, k_theta):
        x, y = X
        return E_min + 0.5*k_r*((x-r_min)**2) + 0.5*k_theta*((y-theta_min))**2
    popt, pcov = (curve_fit(vibrational_model, (fit_df['r'], fit_df['theta']), fit_df['Energy']))
    return popt, pcov

def get_vibrational_frequencies(df: pd.DataFrame):
    r_min, theta_min, E_min = find_min(df)
    popt, pcov = fit_curve(df)
    k_r = popt[0]
    k_theta = popt[1]

    # Hartree to J
    E_h = 4.3597447222071 * 10**(-18)
    # Angstrom to m
    A = 10**(-10)
    # Speed of light in cm s**-1
    v_c = 29979245800
    # Atomic mass unit in kg
    amu = 1.66053906660 * 10**(-27)
    # Degree in radians
    deg = np.pi/180

    v1 = np.sqrt((k_r*E_h*A**-2)/(2*amu))/(2*np.pi*v_c)
    v2 = np.sqrt(k_theta*E_h/((A**2)*(r_min**2)*(0.5*amu)))/(2*np.pi*v_c*deg)

    return v1, v2

if __name__ == '__main__':
    directory = str(input())
    df = outfiles_to_df(directory)
    plot_energy_surface(df)
    print(get_vibrational_frequencies(df))
